<!DOCTYPE html>
<html lang="en">
<!--
  ============================================================================
  NFL Power Ratings Calculator
  ============================================================================
  A production-ready web application that calculates NFL team power ratings
  using Ordinary Least Squares (OLS) regression on game data.
  
  Author: Senior JavaScript Developer
  Style Guide: Airbnb JavaScript Style Guide
  License: MIT
  
  Features:
  - Parquet file parsing from GitHub repository
  - Season and week range filtering
  - OLS regression with home-field advantage adjustment
  - Neutral site game handling
  - Responsive, sports-themed UI design
  ============================================================================
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Rob Schoen's NFL Power Ratings Calculator: Point Differential & Strength of Schedule">
    <title>NFL Power Ratings Calculator</title>

    <!-- 
    Google Fonts: Using Oswald for bold headlines and Source Sans 3 for body text.
    This combination provides a sports/athletic aesthetic while maintaining readability.
  -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Source+Sans+3:wght@400;600;700&display=swap"
        rel="stylesheet">

    <style>
        /* ========================================================================
       CSS CUSTOM PROPERTIES (Design Tokens)
       ========================================================================
       Centralized design tokens for consistent theming throughout the app.
       Using a dark, athletic-inspired color palette with orange/gold accents.
    */
        :root {
            /* Primary Colors - Dark athletic theme */
            --color-bg-primary: #0a0f14;
            --color-bg-secondary: #121a24;
            --color-bg-tertiary: #1a2634;
            --color-bg-card: #162029;

            /* Accent Colors - Sports energy */
            --color-accent-primary: #ff6b35;
            --color-accent-secondary: #f7c948;
            --color-accent-glow: rgba(255, 107, 53, 0.4);

            /* Text Colors */
            --color-text-primary: #ffffff;
            --color-text-secondary: #a8b9cc;
            --color-text-muted: #6b7d8f;

            /* Positive/Negative indicators for ratings */
            --color-positive: #4ade80;
            --color-negative: #f87171;
            --color-neutral: #fbbf24;

            /* Typography */
            --font-display: 'Oswald', sans-serif;
            --font-body: 'Source Sans 3', sans-serif;

            /* Spacing Scale */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            --space-3xl: 4rem;

            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;

            /* Shadows */
            --shadow-card: 0 4px 24px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 30px var(--color-accent-glow);

            /* Transitions */
            --transition-fast: 150ms ease;
            --transition-base: 250ms ease;
            --transition-slow: 400ms ease;
        }

        /* ========================================================================
       CSS RESET & BASE STYLES
       ========================================================================
    */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-body);
            font-weight: 400;
            line-height: 1.6;
            color: var(--color-text-primary);
            background: var(--color-bg-primary);
            min-height: 100vh;

            /* Subtle gradient background for depth */
            background:
                radial-gradient(ellipse at 20% 0%, rgba(255, 107, 53, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(247, 201, 72, 0.05) 0%, transparent 50%),
                var(--color-bg-primary);
        }

        /* ========================================================================
       LAYOUT COMPONENTS
       ========================================================================
    */

        /* Main container with max-width constraint */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-lg);
        }

        /* ========================================================================
       HEADER STYLES
       ========================================================================
       Bold, impactful header with athletic styling.
    */
        .header {
            text-align: center;
            padding: var(--space-3xl) 0 var(--space-2xl);
            position: relative;
        }

        .header::before {
            /* Decorative accent line above title */
            content: '';
            position: absolute;
            top: var(--space-xl);
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 4px;
            background: linear-gradient(90deg, var(--color-accent-primary), var(--color-accent-secondary));
            border-radius: 2px;
        }

        .header__title {
            font-family: var(--font-display);
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            line-height: 1.1;

            /* Gradient text effect */
            background: linear-gradient(135deg, var(--color-text-primary) 0%, var(--color-accent-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header__subtitle {
            font-family: var(--font-body);
            font-size: 1.125rem;
            color: var(--color-text-secondary);
            margin-top: var(--space-md);
            font-weight: 400;
        }

        /* ========================================================================
       CONTROL PANEL STYLES
       ========================================================================
       The main interface for season/week selection.
    */
        .control-panel {
            background: var(--color-bg-card);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            margin-bottom: var(--space-xl);
            box-shadow: var(--shadow-card);
        }

        .control-panel__title {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--color-accent-secondary);
            margin-bottom: var(--space-lg);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .control-panel__title::before {
            /* Small decorative square */
            content: '';
            width: 8px;
            height: 8px;
            background: var(--color-accent-primary);
            border-radius: 2px;
        }

        /* Form grid layout for controls */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-xl);
        }

        /* Individual form field styling */
        .form-field {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .form-field__label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Select dropdown styling */
        .form-field__select {
            appearance: none;
            background: var(--color-bg-tertiary);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--space-md) var(--space-lg);
            padding-right: 3rem;
            font-family: var(--font-body);
            font-size: 1rem;
            font-weight: 600;
            color: var(--color-text-primary);
            cursor: pointer;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);

            /* Custom dropdown arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a8b9cc' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right var(--space-md) center;
        }

        .form-field__select:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }

        .form-field__select:focus {
            outline: none;
            border-color: var(--color-accent-primary);
            box-shadow: 0 0 0 3px var(--color-accent-glow);
        }

        /* Calculate button styling */
        .btn-calculate {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            width: 100%;
            padding: var(--space-md) var(--space-xl);
            font-family: var(--font-display);
            font-size: 1.125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--color-bg-primary);
            background: linear-gradient(135deg, var(--color-accent-primary), var(--color-accent-secondary));
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast);
        }

        .btn-calculate:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .btn-calculate:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn-calculate:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Loading spinner for button */
        .btn-calculate__spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: var(--color-bg-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: none;
        }

        .btn-calculate--loading .btn-calculate__spinner {
            display: block;
        }

        .btn-calculate--loading .btn-calculate__text {
            display: none;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ========================================================================
       STATUS MESSAGE STYLES
       ========================================================================
    */
        .status-message {
            text-align: center;
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            font-weight: 600;
            display: none;
        }

        .status-message--visible {
            display: block;
            animation: fadeIn var(--transition-base);
        }

        .status-message--loading {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
            color: var(--color-accent-primary);
        }

        .status-message--error {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid rgba(248, 113, 113, 0.3);
            color: var(--color-negative);
        }

        .status-message--success {
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid rgba(74, 222, 128, 0.3);
            color: var(--color-positive);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ========================================================================
       RESULTS TABLE STYLES
       ========================================================================
       Clean, data-focused table for power ratings display.
    */
        .results-section {
            display: none;
        }

        .results-section--visible {
            display: block;
            animation: slideUp var(--transition-slow);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .results-title {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .results-meta {
            font-size: 0.875rem;
            color: var(--color-text-muted);
        }

        .results-meta span {
            color: var(--color-accent-secondary);
            font-weight: 600;
        }

        /* Table container with horizontal scroll for mobile */
        .table-container {
            background: var(--color-bg-card);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-card);
            max-height: 500px;
            overflow-y: auto;
        }

        /* Sticky header when scrolling */
        .results-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--color-bg-tertiary);
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9375rem;
        }

        .results-table th {
            font-family: var(--font-display);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.75rem;
            color: var(--color-text-secondary);
            padding: var(--space-md) var(--space-lg);
            text-align: left;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }

        .results-table th:hover {
            color: var(--color-accent-primary);
        }

        .results-table th.sort-active {
            color: var(--color-accent-secondary);
        }

        .results-table th .sort-indicator {
            margin-left: var(--space-xs);
            opacity: 0.5;
        }

        .results-table th.sort-active .sort-indicator {
            opacity: 1;
        }

        .results-table th:last-child,
        .results-table td:last-child {
            text-align: right;
        }

        .results-table tbody tr {
            transition: background var(--transition-fast);
        }

        .results-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .results-table td {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Rank column styling */
        .rank-cell {
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--color-text-muted);
            width: 60px;
        }

        .rank-cell--top3 {
            color: var(--color-accent-secondary);
        }

        /* Team name styling */
        .team-cell {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .team-cell__abbr {
            font-family: var(--font-display);
            font-size: 0.75rem;
            color: var(--color-text-muted);
            background: var(--color-bg-tertiary);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
        }

        /* Power rating value styling */
        .rating-cell {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 1.125rem;
        }

        .rating-cell--positive {
            color: var(--color-positive);
        }

        .rating-cell--negative {
            color: var(--color-negative);
        }

        .rating-cell--neutral {
            color: var(--color-neutral);
        }

        /* W-L-T record styling */
        .record-cell {
            font-family: var(--font-display);
            font-weight: 600;
            font-size: 0.9375rem;
            color: var(--color-text-secondary);
            text-align: center;
            width: 60px;
        }

        /* Home field advantage display */
        .hfa-display {
            margin-top: var(--space-md);
            padding: var(--space-sm) var(--space-md);
            background: var(--color-bg-tertiary);
            border-radius: var(--radius-md);
            display: inline-block;
            font-size: 0.875rem;
        }

        .hfa-display__label {
            font-size: 0.75rem;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: inline;
            margin-right: var(--space-sm);
        }

        .hfa-display__value {
            font-family: var(--font-display);
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--color-accent-secondary);
        }

        .hfa-display__unit {
            font-size: 0.875rem;
            color: var(--color-text-muted);
            margin-left: var(--space-xs);
        }

        /* ========================================================================
       FOOTER STYLES
       ========================================================================
    */
        .footer {
            text-align: center;
            padding: var(--space-2xl) 0 var(--space-xl);
            color: var(--color-text-muted);
            font-size: 0.875rem;
        }

        .footer a {
            color: var(--color-accent-primary);
            text-decoration: none;
            transition: color var(--transition-fast);
        }

        .footer a:hover {
            color: var(--color-accent-secondary);
        }

        /* ========================================================================
       FILE UPLOAD FALLBACK STYLES
       ========================================================================
    */
        .file-upload-section {
            background: rgba(255, 107, 53, 0.1);
            border: 1px dashed var(--color-accent-primary);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
            text-align: center;
        }

        .file-upload-note {
            color: var(--color-text-secondary);
            margin-bottom: var(--space-md);
        }

        .file-upload-input {
            display: block;
            width: 100%;
            padding: var(--space-md);
            background: var(--color-bg-tertiary);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            color: var(--color-text-primary);
            cursor: pointer;
            margin-bottom: var(--space-sm);
        }

        .file-upload-input:hover {
            border-color: var(--color-accent-primary);
        }

        .file-upload-hint {
            font-size: 0.875rem;
            color: var(--color-text-muted);
        }

        .file-upload-hint a {
            color: var(--color-accent-primary);
            text-decoration: none;
        }

        .file-upload-hint a:hover {
            text-decoration: underline;
        }

        /* ========================================================================
       RESPONSIVE ADJUSTMENTS
       ========================================================================
    */
        @media (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }

            .control-panel {
                padding: var(--space-lg);
            }

            .results-table {
                font-size: 0.8125rem;
            }

            .results-table th,
            .results-table td {
                padding: var(--space-xs) var(--space-sm);
            }

            .results-table th {
                font-size: 0.625rem;
            }

            /* Hide team abbreviation badge on mobile */
            .team-cell__abbr {
                display: none;
            }

            /* Make team names more compact on mobile */
            .team-cell {
                font-size: 0.8125rem;
                min-width: 100px;
            }

            /* Reduce rank column width */
            .rank-cell {
                width: 35px;
                font-size: 0.875rem;
            }

            /* Reduce record columns width */
            .record-cell {
                width: 35px;
                font-size: 0.8125rem;
                padding: var(--space-xs) 2px;
            }

            /* Ensure rating column stays visible */
            .rating-cell {
                font-size: 0.9375rem;
                white-space: nowrap;
            }

            /* Make HFA display even more compact on mobile */
            .hfa-display {
                font-size: 0.75rem;
                padding: var(--space-xs) var(--space-sm);
            }

            .hfa-display__label {
                font-size: 0.625rem;
            }

            .hfa-display__value {
                font-size: 0.9375rem;
            }

            .hfa-display__unit {
                font-size: 0.75rem;
            }
        }
    </style>
</head>

<body>
    <!-- ========================================================================
       MAIN APPLICATION CONTAINER
       ======================================================================== -->
    <div class="container">

        <!-- Page Header -->
        <header class="header">
            <h1 class="header__title">NFL Power Ratings</h1>
            <p class="header__subtitle">
                Ratings based on point differential and strength of schedule
            </p>
        </header>

        <!-- Control Panel: Season and Week Selection -->
        <section class="control-panel">

            <!-- File Upload Fallback (hidden by default, shown on error) -->
            <div id="file-upload-section" class="file-upload-section" style="display: none;">
                <p class="file-upload-note">
                    Remote data loading failed. Upload a CSV file manually:
                </p>
                <input type="file" id="file-upload" accept=".csv" class="file-upload-input">
                <p class="file-upload-hint">
                    Download from: <a href="https://github.com/nflverse/nfldata/blob/master/data/games.csv"
                        target="_blank" rel="noopener noreferrer">nflverse/nfldata games.csv</a>
                </p>
            </div>

            <div class="controls-grid">
                <!-- Season Selector -->
                <div class="form-field">
                    <label for="season-select" class="form-field__label">Season</label>
                    <select id="season-select" class="form-field__select">
                        <!-- Options populated dynamically -->
                    </select>
                </div>

                <!-- Start Week Selector -->
                <div class="form-field">
                    <label for="start-week-select" class="form-field__label">Start Week</label>
                    <select id="start-week-select" class="form-field__select">
                        <!-- Options populated dynamically -->
                    </select>
                </div>

                <!-- End Week Selector -->
                <div class="form-field">
                    <label for="end-week-select" class="form-field__label">End Week</label>
                    <select id="end-week-select" class="form-field__select">
                        <!-- Options populated dynamically -->
                    </select>
                </div>
            </div>

            <!-- Calculate Button -->
            <button id="calculate-btn" class="btn-calculate" type="button">
                <span class="btn-calculate__spinner"></span>
                <span class="btn-calculate__text">Calculate Power Ratings</span>
            </button>
        </section>

        <!-- Status Message Display -->
        <div id="status-message" class="status-message" role="status" aria-live="polite"></div>

        <!-- Results Section: Power Ratings Table -->
        <section id="results-section" class="results-section">
            <div class="results-header">
                <h2 class="results-title">Power Ratings</h2>
                <p class="results-meta">
                    <span id="games-count">0</span> games analyzed
                </p>
            </div>

            <div class="table-container">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th data-sort="rank" class="sort-active">Rank <span class="sort-indicator">▼</span></th>
                            <th data-sort="team">Team <span class="sort-indicator">▼</span></th>
                            <th data-sort="wins">Wins <span class="sort-indicator">▼</span></th>
                            <th data-sort="losses">Losses <span class="sort-indicator">▼</span></th>
                            <th data-sort="ties">Ties <span class="sort-indicator">▼</span></th>
                            <th data-sort="rating">Power Rating <span class="sort-indicator">▼</span></th>
                        </tr>
                    </thead>
                    <tbody id="results-body">
                        <!-- Results populated dynamically -->
                    </tbody>
                </table>
            </div>

            <!-- Home Field Advantage Display -->
            <div class="hfa-display">
                <span class="hfa-display__label">Home Field Advantage:</span>
                <span id="hfa-value" class="hfa-display__value">0.0</span>
                <span class="hfa-display__unit">points</span>
            </div>
        </section>

        <!-- Page Footer -->
        <footer class="footer">
            <p>
                Data from
                <a href="https://github.com/nflverse/nfldata" target="_blank" rel="noopener noreferrer">
                    nflverse/nfldata
                </a>
            </p>
        </footer>
    </div>

    <!-- ========================================================================
       JAVASCRIPT APPLICATION
       ========================================================================
       Main application logic for NFL Power Ratings calculation.
       Follows Airbnb JavaScript Style Guide conventions.
  -->
    <script>
        /**
         * =========================================================================
         * NFL POWER RATINGS CALCULATOR
         * =========================================================================
         * 
         * This application calculates NFL team power ratings using Ordinary Least
         * Squares (OLS) regression. The methodology treats each game as an
         * observation where the point differential is explained by the relative
         * strength of the competing teams plus home-field advantage.
         * 
         * Mathematical Model:
         * y = Xβ + ε
         * 
         * Where:
         * - y = vector of point differentials (home score - away score)
         * - X = design matrix with team indicators and home-field indicator
         * - β = coefficients (power ratings + home-field advantage)
         * - ε = error term
         * 
         * Solution: β = (X'X)^(-1) X'y
         */

        'use strict';

        // =========================================================================
        // CONSTANTS AND CONFIGURATION
        // =========================================================================

        /**
         * Primary URL for NFL games CSV data.
         * habitatring.com hosts nflverse-compatible game data with CORS support.
         * @constant {string}
         */
        const CSV_URL_PRIMARY = 'https://www.habitatring.com/games.csv';

        /**
         * Fallback URL - Lee Sharpe's nfldata mirror.
         * @constant {string}
         */
        const CSV_URL_FALLBACK = 'https://raw.githubusercontent.com/nflverse/nfldata/master/data/games.csv';

        /**
         * NFL team abbreviations mapped to matrix column indices.
         * Teams are ordered alphabetically for consistent indexing.
         * Index 0 is reserved for home-field advantage constant.
         * @constant {Object.<string, number>}
         */
        const TEAM_INDEX_MAP = {
            ARI: 1, ATL: 2, BAL: 3, BUF: 4, CAR: 5, CHI: 6, CIN: 7, CLE: 8,
            DAL: 9, DEN: 10, DET: 11, GB: 12, HOU: 13, IND: 14, JAX: 15, KC: 16,
            LAC: 17, LAR: 18, LV: 19, MIA: 20, MIN: 21, NE: 22, NO: 23, NYG: 24,
            NYJ: 25, PHI: 26, PIT: 27, SEA: 28, SF: 29, TB: 30, TEN: 31, WAS: 32,
        };

        /**
         * Reverse mapping from index to team abbreviation.
         * Used for displaying results in the table.
         * @constant {Object.<number, string>}
         */
        const INDEX_TEAM_MAP = Object.fromEntries(
            Object.entries(TEAM_INDEX_MAP).map(([team, index]) => [index, team]),
        );

        /**
         * Full team names for display purposes.
         * Provides user-friendly names alongside abbreviations.
         * @constant {Object.<string, string>}
         */
        const TEAM_NAMES = {
            ARI: 'Arizona Cardinals', ATL: 'Atlanta Falcons', BAL: 'Baltimore Ravens',
            BUF: 'Buffalo Bills', CAR: 'Carolina Panthers', CHI: 'Chicago Bears',
            CIN: 'Cincinnati Bengals', CLE: 'Cleveland Browns', DAL: 'Dallas Cowboys',
            DEN: 'Denver Broncos', DET: 'Detroit Lions', GB: 'Green Bay Packers',
            HOU: 'Houston Texans', IND: 'Indianapolis Colts', JAX: 'Jacksonville Jaguars',
            KC: 'Kansas City Chiefs', LAC: 'Los Angeles Chargers', LAR: 'Los Angeles Rams',
            LV: 'Las Vegas Raiders', MIA: 'Miami Dolphins', MIN: 'Minnesota Vikings',
            NE: 'New England Patriots', NO: 'New Orleans Saints', NYG: 'New York Giants',
            NYJ: 'New York Jets', PHI: 'Philadelphia Eagles', PIT: 'Pittsburgh Steelers',
            SEA: 'Seattle Seahawks', SF: 'San Francisco 49ers', TB: 'Tampa Bay Buccaneers',
            TEN: 'Tennessee Titans', WAS: 'Washington Commanders',
        };

        /**
         * Historical team abbreviation mappings for relocated/renamed franchises.
         * Maps old abbreviations to their current equivalents.
         * @constant {Object.<string, string>}
         */
        const TEAM_ALIASES = {
            // San Diego Chargers -> Los Angeles Chargers (2017)
            SD: 'LAC',
            // St. Louis Rams -> Los Angeles Rams (2016)
            STL: 'LAR',
            // nflverse uses "LA" for Rams (they were first LA team after relocation)
            LA: 'LAR',
            // Oakland Raiders -> Las Vegas Raiders (2020)
            OAK: 'LV',
            // Washington variations over the years
            WSH: 'WAS',
        };

        /**
         * Week number to label mapping for display purposes.
         * Includes regular season weeks (1-18) and playoff rounds (19-22).
         * @constant {Object.<number, string>}
         */
        const WEEK_LABELS = {
            1: 'Week 1', 2: 'Week 2', 3: 'Week 3', 4: 'Week 4',
            5: 'Week 5', 6: 'Week 6', 7: 'Week 7', 8: 'Week 8',
            9: 'Week 9', 10: 'Week 10', 11: 'Week 11', 12: 'Week 12',
            13: 'Week 13', 14: 'Week 14', 15: 'Week 15', 16: 'Week 16',
            17: 'Week 17', 18: 'Week 18',
            19: 'Wild Card', 20: 'Divisional', 21: 'Conference', 22: 'Super Bowl',
        };

        /**
         * Number of NFL teams (used for matrix dimensions).
         * @constant {number}
         */
        const NUM_TEAMS = 32;

        /**
         * Total number of columns in design matrix (teams + HFA constant).
         * @constant {number}
         */
        const NUM_PREDICTORS = NUM_TEAMS + 1;

        // =========================================================================
        // DOM ELEMENT REFERENCES
        // =========================================================================

        /**
         * Cache DOM element references for performance.
         * Avoids repeated querySelector calls during runtime.
         */
        const elements = {
            seasonSelect: document.getElementById('season-select'),
            startWeekSelect: document.getElementById('start-week-select'),
            endWeekSelect: document.getElementById('end-week-select'),
            calculateBtn: document.getElementById('calculate-btn'),
            statusMessage: document.getElementById('status-message'),
            resultsSection: document.getElementById('results-section'),
            resultsBody: document.getElementById('results-body'),
            gamesCount: document.getElementById('games-count'),
            hfaValue: document.getElementById('hfa-value'),
            fileUploadSection: document.getElementById('file-upload-section'),
            fileUpload: document.getElementById('file-upload'),
        };

        // =========================================================================
        // APPLICATION STATE
        // =========================================================================

        /**
         * Global application state.
         * Stores parsed game data and available seasons.
         */
        const appState = {
            /** @type {Array<Object>} Parsed game records from parquet file */
            gamesData: [],
            /** @type {Set<number>} Set of available seasons in the dataset */
            availableSeasons: new Set(),
            /** @type {boolean} Whether data has been loaded */
            dataLoaded: false,
            /** @type {Array<Object>} Current power ratings results for sorting */
            currentRatings: [],
            /** @type {number} Current home field advantage value */
            currentHFA: 0,
            /** @type {string} Current sort column ('rank', 'team', 'rating') */
            sortColumn: 'rank',
            /** @type {string} Current sort direction ('asc' or 'desc') */
            sortDirection: 'desc',
        };

        // =========================================================================
        // UTILITY FUNCTIONS
        // =========================================================================

        /**
         * Normalizes team abbreviations to handle historical name changes.
         * Converts old abbreviations (SD, STL, OAK) to current ones (LAC, LAR, LV).
         * 
         * @param {string} abbr - Team abbreviation to normalize
         * @returns {string} Normalized team abbreviation
         * 
         * @example
         * normalizeTeamAbbr('SD');  // Returns 'LAC'
         * normalizeTeamAbbr('KC');  // Returns 'KC' (unchanged)
         */
        function normalizeTeamAbbr(abbr) {
            // Check if abbreviation needs aliasing
            const normalized = TEAM_ALIASES[abbr] || abbr;

            // Validate that the normalized abbreviation exists in our team map
            if (!TEAM_INDEX_MAP[normalized]) {
                console.warn(`Unknown team abbreviation: ${abbr}`);
                return null;
            }

            return normalized;
        }

        /**
         * Displays a status message to the user.
         * Handles different message types (loading, error, success) with appropriate styling.
         * 
         * @param {string} message - Message text to display
         * @param {('loading'|'error'|'success')} type - Message type for styling
         */
        function showStatus(message, type) {
            const { statusMessage } = elements;

            // Remove existing type classes
            statusMessage.classList.remove(
                'status-message--loading',
                'status-message--error',
                'status-message--success',
            );

            // Add appropriate type class and show message
            statusMessage.classList.add(`status-message--${type}`, 'status-message--visible');
            statusMessage.textContent = message;
        }

        /**
         * Hides the status message from view.
         */
        function hideStatus() {
            elements.statusMessage.classList.remove('status-message--visible');
        }

        /**
         * Sets the loading state of the calculate button.
         * Disables button and shows spinner during processing.
         * 
         * @param {boolean} isLoading - Whether the application is in loading state
         */
        function setButtonLoading(isLoading) {
            const { calculateBtn } = elements;

            if (isLoading) {
                calculateBtn.classList.add('btn-calculate--loading');
                calculateBtn.disabled = true;
            } else {
                calculateBtn.classList.remove('btn-calculate--loading');
                calculateBtn.disabled = false;
            }
        }

        // =========================================================================
        // MATRIX OPERATIONS FOR OLS REGRESSION
        // =========================================================================

        /**
         * Creates a zero-filled matrix of specified dimensions.
         * Used for initializing the design matrix and intermediate calculations.
         * 
         * @param {number} rows - Number of rows
         * @param {number} cols - Number of columns
         * @returns {Array<Array<number>>} Zero-filled matrix
         */
        function createMatrix(rows, cols) {
            return Array.from({ length: rows }, () => Array(cols).fill(0));
        }

        /**
         * Creates a zero-filled vector of specified length.
         * Used for initializing the target vector.
         * 
         * @param {number} length - Length of vector
         * @returns {Array<number>} Zero-filled vector
         */
        function createVector(length) {
            return Array(length).fill(0);
        }

        /**
         * Computes the transpose of a matrix.
         * Converts an m×n matrix to an n×m matrix.
         * 
         * @param {Array<Array<number>>} matrix - Input matrix
         * @returns {Array<Array<number>>} Transposed matrix
         * 
         * @example
         * transposeMatrix([[1, 2], [3, 4]]);  // Returns [[1, 3], [2, 4]]
         */
        function transposeMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;

            // Create transposed matrix with swapped dimensions
            const transposed = createMatrix(cols, rows);

            // Swap row and column indices
            for (let i = 0; i < rows; i += 1) {
                for (let j = 0; j < cols; j += 1) {
                    transposed[j][i] = matrix[i][j];
                }
            }

            return transposed;
        }

        /**
         * Multiplies two matrices together.
         * Computes C = A × B where A is m×n and B is n×p.
         * 
         * @param {Array<Array<number>>} A - First matrix (m×n)
         * @param {Array<Array<number>>} B - Second matrix (n×p)
         * @returns {Array<Array<number>>} Result matrix (m×p)
         * @throws {Error} If matrix dimensions are incompatible
         */
        function multiplyMatrices(A, B) {
            const rowsA = A.length;
            const colsA = A[0].length;
            const rowsB = B.length;
            const colsB = B[0].length;

            // Validate dimensions for multiplication
            if (colsA !== rowsB) {
                throw new Error(`Matrix dimensions incompatible: ${colsA} !== ${rowsB}`);
            }

            // Initialize result matrix
            const result = createMatrix(rowsA, colsB);

            // Compute matrix product
            for (let i = 0; i < rowsA; i += 1) {
                for (let j = 0; j < colsB; j += 1) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k += 1) {
                        sum += A[i][k] * B[k][j];
                    }
                    result[i][j] = sum;
                }
            }

            return result;
        }

        /**
         * Multiplies a matrix by a vector.
         * Computes y = Ax where A is m×n and x is n×1.
         * 
         * @param {Array<Array<number>>} matrix - Input matrix (m×n)
         * @param {Array<number>} vector - Input vector (n×1)
         * @returns {Array<number>} Result vector (m×1)
         */
        function multiplyMatrixVector(matrix, vector) {
            const rows = matrix.length;
            const cols = matrix[0].length;

            // Validate dimensions
            if (cols !== vector.length) {
                throw new Error('Matrix and vector dimensions incompatible');
            }

            // Compute matrix-vector product
            const result = createVector(rows);
            for (let i = 0; i < rows; i += 1) {
                let sum = 0;
                for (let j = 0; j < cols; j += 1) {
                    sum += matrix[i][j] * vector[j];
                }
                result[i] = sum;
            }

            return result;
        }

        /**
         * Computes the inverse of a square matrix using Gauss-Jordan elimination.
         * This implementation handles the X'X matrix from OLS regression.
         * 
         * Algorithm:
         * 1. Augment input matrix with identity matrix [A|I]
         * 2. Apply row operations to transform to [I|A^-1]
         * 3. Extract the inverse from the augmented matrix
         * 
         * @param {Array<Array<number>>} matrix - Square matrix to invert
         * @returns {Array<Array<number>>} Inverted matrix
         * @throws {Error} If matrix is singular (non-invertible)
         */
        function invertMatrix(matrix) {
            const n = matrix.length;

            // Create augmented matrix [A|I]
            const augmented = matrix.map((row, i) => {
                const identityRow = Array(n).fill(0);
                identityRow[i] = 1;
                return [...row, ...identityRow];
            });

            // Forward elimination with partial pivoting
            for (let col = 0; col < n; col += 1) {
                // Find pivot (largest absolute value in column)
                let maxRow = col;
                let maxVal = Math.abs(augmented[col][col]);

                for (let row = col + 1; row < n; row += 1) {
                    const absVal = Math.abs(augmented[row][col]);
                    if (absVal > maxVal) {
                        maxVal = absVal;
                        maxRow = row;
                    }
                }

                // Swap rows if necessary for numerical stability
                if (maxRow !== col) {
                    [augmented[col], augmented[maxRow]] = [augmented[maxRow], augmented[col]];
                }

                // Check for singular matrix
                const pivot = augmented[col][col];
                if (Math.abs(pivot) < 1e-12) {
                    // Handle near-singular matrix by adding small regularization
                    augmented[col][col] = 1e-10;
                }

                // Scale pivot row to make pivot element equal to 1
                const scaleFactor = augmented[col][col];
                for (let j = 0; j < 2 * n; j += 1) {
                    augmented[col][j] /= scaleFactor;
                }

                // Eliminate column entries in other rows
                for (let row = 0; row < n; row += 1) {
                    if (row !== col) {
                        const factor = augmented[row][col];
                        for (let j = 0; j < 2 * n; j += 1) {
                            augmented[row][j] -= factor * augmented[col][j];
                        }
                    }
                }
            }

            // Extract inverse from augmented matrix
            const inverse = augmented.map((row) => row.slice(n));

            return inverse;
        }

        // =========================================================================
        // OLS REGRESSION IMPLEMENTATION
        // =========================================================================

        /**
         * Builds the design matrix (X) and target vector (y) for OLS regression.
         * 
         * Design Matrix Structure (N × 33):
         * - Column 0: Home-field advantage indicator (1 for home game, 0 for neutral)
         * - Columns 1-32: Team indicators (+1 for home team, -1 for away team)
         * 
         * Target Vector (N × 1):
         * - Point differential for each game (home_score - away_score)
         * 
         * @param {Array<Object>} games - Array of filtered game objects
         * @returns {{X: Array<Array<number>>, y: Array<number>, validGames: number}} 
         *          Design matrix, target vector, and count of valid games
         */
        function buildDesignMatrix(games) {
            // First pass: filter out games with unknown teams
            const validGames = games.filter((game) => {
                const homeTeam = normalizeTeamAbbr(game.home_team);
                const awayTeam = normalizeTeamAbbr(game.away_team);
                return homeTeam && awayTeam;
            });

            const numGames = validGames.length;

            // Log any skipped games
            if (validGames.length < games.length) {
                console.warn(`Skipped ${games.length - validGames.length} games with unknown teams`);
            }

            // Initialize design matrix and target vector
            const X = createMatrix(numGames, NUM_PREDICTORS);
            const y = createVector(numGames);

            // Populate matrix and vector for each valid game
            validGames.forEach((game, rowIndex) => {
                // Normalize team abbreviations for historical consistency
                const homeTeam = normalizeTeamAbbr(game.home_team);
                const awayTeam = normalizeTeamAbbr(game.away_team);

                // Get team column indices
                const homeIndex = TEAM_INDEX_MAP[homeTeam];
                const awayIndex = TEAM_INDEX_MAP[awayTeam];

                // Column 0: Home-field advantage indicator
                // Set to 1 for regular home games, 0 for neutral site games
                // In the nflverse data, location="Home" means home game
                // Any other value (like "Neutral") indicates neutral site
                const locationValue = String(game.location || '').toLowerCase().trim();
                const isNeutralSite = locationValue !== 'home' && locationValue !== '';
                X[rowIndex][0] = isNeutralSite ? 0 : 1;

                // Set team indicators: +1 for home team, -1 for away team
                X[rowIndex][homeIndex] = 1;
                X[rowIndex][awayIndex] = -1;

                // Target: point differential (home score - away score)
                y[rowIndex] = game.home_score - game.away_score;
            });

            return { X, y, validGames: numGames };
        }

        /**
         * Performs Ordinary Least Squares (OLS) regression.
         * 
         * Computes: β = (X'X)^(-1) X'y
         * 
         * This gives us the coefficients that minimize the sum of squared residuals.
         * The first coefficient is the home-field advantage, and the remaining 32
         * are the raw team power ratings.
         * 
         * @param {Array<Array<number>>} X - Design matrix (N × 33)
         * @param {Array<number>} y - Target vector (N × 1)
         * @returns {Array<number>} Coefficient vector (33 × 1)
         */
        function performOLSRegression(X, y) {
            // Step 1: Compute X transpose
            const Xt = transposeMatrix(X);

            // Step 2: Compute X'X (33 × 33 matrix)
            const XtX = multiplyMatrices(Xt, X);

            // Step 3: Compute X'y (33 × 1 vector)
            const Xty = multiplyMatrixVector(Xt, y);

            // Step 4: Compute (X'X)^(-1)
            const XtXInv = invertMatrix(XtX);

            // Step 5: Compute β = (X'X)^(-1) X'y
            const beta = multiplyMatrixVector(XtXInv, Xty);

            return beta;
        }

        /**
         * Calculates team records (wins, losses, ties) from filtered games.
         *
         * @param {Array<Object>} games - Array of game objects
         * @returns {Object.<string, {wins: number, losses: number, ties: number}>} Record by team
         */
        function calculateTeamRecords(games) {
            const records = {};

            // Initialize records for all teams
            Object.keys(TEAM_INDEX_MAP).forEach((team) => {
                records[team] = { wins: 0, losses: 0, ties: 0 };
            });

            // Process each game
            games.forEach((game) => {
                const homeTeam = normalizeTeamAbbr(game.home_team);
                const awayTeam = normalizeTeamAbbr(game.away_team);

                // Skip games with unknown teams
                if (!homeTeam || !awayTeam) return;

                const { home_score, away_score } = game;

                if (home_score > away_score) {
                    // Home team wins
                    records[homeTeam].wins += 1;
                    records[awayTeam].losses += 1;
                } else if (away_score > home_score) {
                    // Away team wins
                    records[awayTeam].wins += 1;
                    records[homeTeam].losses += 1;
                } else {
                    // Tie game
                    records[homeTeam].ties += 1;
                    records[awayTeam].ties += 1;
                }
            });

            return records;
        }

        /**
         * Calculates final power ratings from OLS coefficients.
         *
         * Process:
         * 1. Extract home-field advantage (first coefficient)
         * 2. Extract raw team ratings (coefficients 2-33)
         * 3. Mean-center the ratings (subtract mean from each)
         *
         * Mean-centering ensures ratings are interpretable:
         * - Positive = above average
         * - Negative = below average
         * - Zero = exactly average
         *
         * @param {Array<number>} beta - OLS coefficient vector
         * @param {Array<Object>} games - Array of game objects for record calculation
         * @returns {{homeFieldAdvantage: number, ratings: Array<{team: string, rating: number, wins: number, losses: number, ties: number}>}}
         */
        function calculatePowerRatings(beta, games) {
            // Extract home-field advantage (first coefficient)
            const homeFieldAdvantage = beta[0];

            // Extract team coefficients (indices 1-32)
            const teamBetas = beta.slice(1);

            // Calculate mean of team betas for centering
            const meanBeta = teamBetas.reduce((sum, val) => sum + val, 0) / teamBetas.length;

            // Calculate team records
            const teamRecords = calculateTeamRecords(games);

            // Mean-center the ratings and pair with team names and records
            const ratings = teamBetas.map((rawRating, index) => {
                const teamAbbr = INDEX_TEAM_MAP[index + 1];
                const record = teamRecords[teamAbbr];
                return {
                    team: teamAbbr,
                    teamName: TEAM_NAMES[teamAbbr],
                    rating: rawRating - meanBeta,
                    wins: record.wins,
                    losses: record.losses,
                    ties: record.ties,
                };
            });

            // Sort ratings in descending order (best teams first)
            ratings.sort((a, b) => b.rating - a.rating);

            return { homeFieldAdvantage, ratings };
        }

        // =========================================================================
        // DATA LOADING AND PARSING
        // =========================================================================

        /**
         * Fetches and parses NFL games data from CSV.
         * Tries primary URL first, then fallback.
         * 
         * @returns {Promise<Array<Object>>} Parsed game records
         * @throws {Error} If all fetch attempts fail
         */
        async function loadGamesData() {
            const urlsToTry = [CSV_URL_PRIMARY, CSV_URL_FALLBACK];
            let lastError = null;

            for (let i = 0; i < urlsToTry.length; i += 1) {
                const url = urlsToTry[i];
                const sourceName = i === 0 ? 'primary' : 'fallback';

                try {
                    showStatus(`Loading NFL games data (${sourceName} source)...`, 'loading');
                    console.log(`Attempting to load CSV from: ${url}`);

                    const response = await fetch(url);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const csvText = await response.text();
                    showStatus('Parsing game data...', 'loading');

                    const games = parseCSV(csvText);

                    if (games.length === 0) {
                        throw new Error('No valid game data found');
                    }

                    console.log(`Successfully loaded ${games.length} games from ${url}`);
                    console.log('Sample game:', games[0]);

                    return games;
                } catch (error) {
                    console.warn(`Failed to load from ${url}:`, error.message);
                    lastError = error;
                }
            }

            throw new Error(`Failed to load games data: ${lastError?.message || 'Unknown error'}`);
        }

        /**
         * Checks if a score value represents a valid played game score.
         * Returns false for empty, null, undefined, NA, or non-numeric values.
         * Returns true for valid numbers including 0 (shutouts are valid).
         * 
         * @param {*} value - The score value to check
         * @returns {boolean} True if the score is valid
         */
        function isValidScore(value) {
            // Check for null, undefined, or empty
            if (value === undefined || value === null || value === '') {
                return false;
            }

            // Convert to string for string checks
            const strValue = String(value).trim().toUpperCase();

            // Check for NA or other non-numeric placeholders
            if (strValue === '' || strValue === 'NA' || strValue === 'N/A' || strValue === 'NULL') {
                return false;
            }

            // Check if it parses to a valid number
            const numValue = Number(value);
            if (Number.isNaN(numValue)) {
                return false;
            }

            return true;
        }

        /**
         * Parses CSV text into game objects.
         * Handles quoted fields and extracts required columns.
         * 
         * @param {string} csvText - Raw CSV content
         * @returns {Array<Object>} Array of game objects
         */
        function parseCSV(csvText) {
            const lines = csvText.split('\n');

            if (lines.length < 2) {
                throw new Error('CSV file appears to be empty');
            }

            // Parse header row to find column indices
            const header = parseCSVLine(lines[0]);
            const columnMap = {};
            header.forEach((col, idx) => {
                columnMap[col.toLowerCase().trim()] = idx;
            });

            console.log('CSV columns found:', header);

            // Get indices for required columns
            const indices = {
                gameId: columnMap.game_id,
                season: columnMap.season,
                week: columnMap.week,
                homeTeam: columnMap.home_team,
                awayTeam: columnMap.away_team,
                homeScore: columnMap.home_score,
                awayScore: columnMap.away_score,
                location: columnMap.location,
            };

            // Validate required columns exist
            const requiredCols = ['season', 'week', 'homeTeam', 'awayTeam', 'homeScore', 'awayScore'];
            const missingCols = requiredCols.filter((col) => indices[col] === undefined);

            if (missingCols.length > 0) {
                throw new Error(`CSV missing required columns: ${missingCols.join(', ')}`);
            }

            // Parse data rows
            const games = [];

            for (let i = 1; i < lines.length; i += 1) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = parseCSVLine(line);

                // Extract field values - check for empty/NA values first
                const homeScoreRaw = values[indices.homeScore];
                const awayScoreRaw = values[indices.awayScore];

                // Skip games with empty, NA, or missing scores (unplayed games)
                // Note: 0 is a valid score (shutout), so we only skip truly empty values
                if (!isValidScore(homeScoreRaw) || !isValidScore(awayScoreRaw)) {
                    continue;
                }

                const homeScore = Number(homeScoreRaw);
                const awayScore = Number(awayScoreRaw);
                const season = Number(values[indices.season]);
                const week = Number(values[indices.week]);

                // Only include completed games with valid numeric scores
                if (Number.isNaN(homeScore) || Number.isNaN(awayScore)) {
                    continue;
                }

                games.push({
                    game_id: indices.gameId !== undefined ? values[indices.gameId] : `game_${i}`,
                    season,
                    week,
                    home_team: values[indices.homeTeam],
                    away_team: values[indices.awayTeam],
                    home_score: homeScore,
                    away_score: awayScore,
                    location: indices.location !== undefined ? values[indices.location] : 'Home',
                });
            }

            return games;
        }

        /**
         * Parses a single CSV line, handling quoted fields correctly.
         * 
         * @param {string} line - CSV line to parse
         * @returns {Array<string>} Array of field values
         */
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i += 1) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            // Don't forget the last field
            values.push(current.trim());

            return values;
        }

        /**
         * Filters games based on selected season and week range.
         * 
         * @param {Array<Object>} games - All game records
         * @param {number} season - Selected season year
         * @param {number} startWeek - Start of week range (inclusive)
         * @param {number} endWeek - End of week range (inclusive)
         * @returns {Array<Object>} Filtered game records
         */
        function filterGames(games, season, startWeek, endWeek) {
            return games.filter((game) => (
                game.season === season
                && game.week >= startWeek
                && game.week <= endWeek
            ));
        }

        // =========================================================================
        // UI POPULATION AND RENDERING
        // =========================================================================

        /**
         * Populates the season dropdown with available seasons.
         * Seasons are displayed in descending order (most recent first).
         * 
         * @param {Set<number>} seasons - Set of available season years
         */
        function populateSeasonDropdown(seasons) {
            const { seasonSelect } = elements;

            // Convert to array and sort descending
            const sortedSeasons = Array.from(seasons).sort((a, b) => b - a);

            // Clear existing options
            seasonSelect.innerHTML = '';

            // Add option for each season
            sortedSeasons.forEach((season) => {
                const option = document.createElement('option');
                option.value = season;
                option.textContent = `${season} Season`;
                seasonSelect.appendChild(option);
            });
        }

        /**
         * Populates the week dropdowns with week options.
         * Includes regular season weeks (1-18) and playoff weeks (19-22).
         * 
         * @param {string} selectId - ID of the select element to populate
         * @param {number} defaultValue - Default selected week
         */
        function populateWeekDropdown(selectId, defaultValue) {
            const selectElement = document.getElementById(selectId);

            // Clear existing options
            selectElement.innerHTML = '';

            // Add options for all weeks (1-22)
            Object.entries(WEEK_LABELS).forEach(([weekNum, weekLabel]) => {
                const option = document.createElement('option');
                option.value = weekNum;
                option.textContent = weekLabel;

                // Set default selection
                if (parseInt(weekNum, 10) === defaultValue) {
                    option.selected = true;
                }

                selectElement.appendChild(option);
            });
        }

        /**
         * Sorts the ratings array based on current sort state.
         *
         * @param {Array<Object>} ratings - Array of rating objects
         * @returns {Array<Object>} Sorted array (new array, original unchanged)
         */
        function sortRatings(ratings) {
            const sorted = [...ratings];
            const { sortColumn, sortDirection } = appState;
            const multiplier = sortDirection === 'asc' ? 1 : -1;

            sorted.sort((a, b) => {
                let comparison = 0;

                switch (sortColumn) {
                    case 'team':
                        // Sort alphabetically by team name
                        comparison = a.teamName.localeCompare(b.teamName);
                        break;
                    case 'rating':
                        // Sort by rating value
                        comparison = a.rating - b.rating;
                        break;
                    case 'wins':
                        // Sort by wins
                        comparison = a.wins - b.wins;
                        break;
                    case 'losses':
                        // Sort by losses
                        comparison = a.losses - b.losses;
                        break;
                    case 'ties':
                        // Sort by ties
                        comparison = a.ties - b.ties;
                        break;
                    case 'rank':
                    default:
                        // Sort by original rank (rating descending)
                        comparison = b.rating - a.rating;
                        // For rank, we want desc to show #1 first
                        return comparison;
                }

                return comparison * multiplier;
            });

            return sorted;
        }

        /**
         * Updates the sort indicator icons in the table header.
         */
        function updateSortIndicators() {
            const headers = document.querySelectorAll('.results-table th[data-sort]');

            headers.forEach((header) => {
                const column = header.getAttribute('data-sort');
                const indicator = header.querySelector('.sort-indicator');

                if (column === appState.sortColumn) {
                    header.classList.add('sort-active');
                    indicator.textContent = appState.sortDirection === 'asc' ? '▲' : '▼';
                } else {
                    header.classList.remove('sort-active');
                    indicator.textContent = '▼';
                }
            });
        }

        /**
         * Handles click on sortable column header.
         * 
         * @param {Event} event - Click event
         */
        function handleSortClick(event) {
            const header = event.target.closest('th[data-sort]');
            if (!header) return;

            const column = header.getAttribute('data-sort');

            // Toggle direction if same column, otherwise default to desc
            if (column === appState.sortColumn) {
                appState.sortDirection = appState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                appState.sortColumn = column;
                appState.sortDirection = 'desc';
            }

            // Re-render with new sort
            updateSortIndicators();
            renderTableBody();
        }

        /**
         * Renders just the table body rows (used for re-sorting).
         */
        function renderTableBody() {
            const { resultsBody } = elements;
            const sortedRatings = sortRatings(appState.currentRatings);

            // Clear existing rows
            resultsBody.innerHTML = '';

            // Render each team row
            sortedRatings.forEach((teamData, index) => {
                // Calculate display rank based on rating (not sort position)
                const originalRank = appState.currentRatings
                    .filter((t) => t.rating > teamData.rating).length + 1;

                const { team, teamName, rating, wins, losses, ties } = teamData;

                // Create table row
                const row = document.createElement('tr');

                // Determine rating color class
                let ratingClass = 'rating-cell--neutral';
                if (rating > 0.5) {
                    ratingClass = 'rating-cell--positive';
                } else if (rating < -0.5) {
                    ratingClass = 'rating-cell--negative';
                }

                // Determine rank styling (top 3 highlighted)
                const rankClass = originalRank <= 3 ? 'rank-cell rank-cell--top3' : 'rank-cell';

                // Build row HTML
                row.innerHTML = `
          <td class="${rankClass}">${originalRank}</td>
          <td class="team-cell">
            ${teamName}
            <span class="team-cell__abbr">${team}</span>
          </td>
          <td class="record-cell">${wins}</td>
          <td class="record-cell">${losses}</td>
          <td class="record-cell">${ties}</td>
          <td class="rating-cell ${ratingClass}">
            ${rating >= 0 ? '+' : ''}${rating.toFixed(2)}
          </td>
        `;

                resultsBody.appendChild(row);
            });
        }

        /**
         * Renders the power ratings results table.
         * Displays team rankings with their power ratings and styling.
         * 
         * @param {{homeFieldAdvantage: number, ratings: Array}} results - Calculation results
         * @param {number} gamesCount - Number of games analyzed
         */
        function renderResultsTable(results, gamesCount) {
            const { resultsSection, hfaValue } = elements;

            // Store results in app state for sorting
            appState.currentRatings = results.ratings;
            appState.currentHFA = results.homeFieldAdvantage;

            // Reset sort to default (rank descending)
            appState.sortColumn = 'rank';
            appState.sortDirection = 'desc';

            // Update games count display
            elements.gamesCount.textContent = gamesCount;

            // Update home field advantage display
            hfaValue.textContent = results.homeFieldAdvantage.toFixed(2);

            // Set up sort click handlers (only once)
            const tableHead = document.querySelector('.results-table thead');
            tableHead.onclick = handleSortClick;

            // Update sort indicators
            updateSortIndicators();

            // Render table body
            renderTableBody();

            // Show results section with animation
            resultsSection.classList.add('results-section--visible');
        }

        // =========================================================================
        // EVENT HANDLERS
        // =========================================================================

        /**
         * Handles the calculate button click event.
         * Orchestrates the full calculation pipeline:
         * 1. Get user selections
         * 2. Filter games
         * 3. Build design matrix
         * 4. Perform OLS regression
         * 5. Calculate and display power ratings
         */
        async function handleCalculateClick() {
            try {
                setButtonLoading(true);
                hideStatus();

                // Get user selections
                const season = parseInt(elements.seasonSelect.value, 10);
                const startWeek = parseInt(elements.startWeekSelect.value, 10);
                const endWeek = parseInt(elements.endWeekSelect.value, 10);

                // Validate week range
                if (startWeek > endWeek) {
                    showStatus('Start week must be less than or equal to end week.', 'error');
                    setButtonLoading(false);
                    return;
                }

                showStatus('Filtering games...', 'loading');

                // Filter games based on selections
                const filteredGames = filterGames(appState.gamesData, season, startWeek, endWeek);

                // Check if we have enough games
                if (filteredGames.length < NUM_TEAMS) {
                    showStatus(
                        `Not enough games found (${filteredGames.length}). Need at least ${NUM_TEAMS} games for analysis.`,
                        'error',
                    );
                    setButtonLoading(false);
                    return;
                }

                showStatus(`Analyzing ${filteredGames.length} games...`, 'loading');

                // Allow UI to update before heavy computation
                await new Promise((resolve) => { setTimeout(resolve, 50); });

                // Build design matrix and target vector
                const { X, y, validGames } = buildDesignMatrix(filteredGames);

                // Check if we have enough valid games after filtering
                if (validGames < NUM_TEAMS) {
                    showStatus(
                        `Not enough valid games (${validGames}). Need at least ${NUM_TEAMS} games for analysis.`,
                        'error',
                    );
                    setButtonLoading(false);
                    return;
                }

                showStatus('Performing OLS regression...', 'loading');

                // Allow UI to update
                await new Promise((resolve) => { setTimeout(resolve, 50); });

                // Perform OLS regression
                const beta = performOLSRegression(X, y);

                // Calculate final power ratings with team records
                const results = calculatePowerRatings(beta, filteredGames);

                // Render results with valid games count
                renderResultsTable(results, validGames);

                // Show success message briefly
                showStatus('Power ratings calculated successfully!', 'success');

                // Hide status after delay
                setTimeout(() => { hideStatus(); }, 2000);
            } catch (error) {
                console.error('Calculation error:', error);
                showStatus(`Error: ${error.message}`, 'error');
            } finally {
                setButtonLoading(false);
            }
        }

        /**
         * Handles week selection changes.
         * Ensures start week doesn't exceed end week and vice versa.
         */
        function handleWeekChange() {
            const startWeek = parseInt(elements.startWeekSelect.value, 10);
            const endWeek = parseInt(elements.endWeekSelect.value, 10);

            // Auto-correct if start exceeds end
            if (startWeek > endWeek) {
                elements.endWeekSelect.value = startWeek;
            }
        }

        /**
         * Handles file upload for manual data loading.
         * Supports CSV files.
         * 
         * @param {Event} event - File input change event
         */
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                setButtonLoading(true);
                showStatus(`Loading ${file.name}...`, 'loading');

                const text = await file.text();
                const games = parseCSV(text);

                if (games.length === 0) {
                    throw new Error('No valid game data found in file');
                }

                // Update application state
                appState.gamesData = games;
                appState.dataLoaded = true;
                appState.availableSeasons.clear();

                games.forEach((game) => {
                    if (game.season) {
                        appState.availableSeasons.add(game.season);
                    }
                });

                populateSeasonDropdown(appState.availableSeasons);

                // Hide upload section
                elements.fileUploadSection.style.display = 'none';
                elements.calculateBtn.disabled = false;

                showStatus(
                    `File loaded successfully! ${games.length.toLocaleString()} games available.`,
                    'success',
                );

                setTimeout(() => { hideStatus(); }, 3000);
            } catch (error) {
                console.error('File upload error:', error);
                showStatus(`Error loading file: ${error.message}`, 'error');
            } finally {
                setButtonLoading(false);
            }
        }

        // =========================================================================
        // APPLICATION INITIALIZATION
        // =========================================================================

        /**
         * Initializes the application.
         * Loads data, populates UI elements, and sets up event listeners.
         */
        async function initializeApp() {
            try {
                // Populate week dropdowns with default values
                populateWeekDropdown('start-week-select', 1);
                populateWeekDropdown('end-week-select', 18);

                // Set up file upload handler
                elements.fileUpload.addEventListener('change', handleFileUpload);

                // Load games data from CSV
                const games = await loadGamesData();

                // Store in application state
                appState.gamesData = games;
                appState.dataLoaded = true;

                // Extract available seasons
                games.forEach((game) => {
                    if (game.season) {
                        appState.availableSeasons.add(game.season);
                    }
                });

                // Populate season dropdown
                populateSeasonDropdown(appState.availableSeasons);

                // Set up event listeners
                elements.calculateBtn.addEventListener('click', handleCalculateClick);
                elements.startWeekSelect.addEventListener('change', handleWeekChange);
                elements.endWeekSelect.addEventListener('change', handleWeekChange);

                // Hide loading status
                hideStatus();

                // Show ready message
                showStatus(
                    `Data loaded successfully! ${games.length.toLocaleString()} games available.`,
                    'success',
                );

                // Hide message after delay
                setTimeout(() => { hideStatus(); }, 3000);
            } catch (error) {
                console.error('Initialization error:', error);
                showStatus(`Failed to load data automatically. Please upload a CSV file manually.`, 'error');

                // Show file upload section
                elements.fileUploadSection.style.display = 'block';

                // Still set up event listeners for when file is uploaded
                elements.calculateBtn.addEventListener('click', handleCalculateClick);
                elements.startWeekSelect.addEventListener('change', handleWeekChange);
                elements.endWeekSelect.addEventListener('change', handleWeekChange);
                elements.calculateBtn.disabled = true;
            }
        }

        // =========================================================================
        // APPLICATION ENTRY POINT
        // =========================================================================

        /**
         * Start the application when the DOM is fully loaded.
         * This ensures all elements are available for manipulation.
         */
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>

</html>